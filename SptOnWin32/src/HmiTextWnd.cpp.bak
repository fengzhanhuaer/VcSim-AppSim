#include "SptProject.h"
using namespace spt;
HmiTextWndPage spt::HmiTextWnd::text[CN_Max_WndCell];
spt::HmiTextWnd::HmiTextWnd(DispType Mode)
{
	updateFunc = 0;
	mode = Mode;
	IniAllPage();
}

void spt::HmiTextWnd::SetPage(uint32 Page, const char* Text)
{
	HmiTextWndPage* page = GetWndCell(Page % CN_Max_WndCell);
	if (page)
	{
		page->SetPage(Page, Text);
	}
}

void spt::HmiTextWnd::Show()
{
	if (mode == E_SinglePage)
	{
		ShowSinglePage();
	}
	else if (mode == E_ScrollPage)
	{
		ShowScrollPage();
	}
	else if (mode == E_ContinuePage)
	{
		ShowContinuePage();
	}
}

void spt::HmiTextWnd::IniAllPage()
{
	for (uint32 i = 0; i < CN_Max_WndCell; i++)
	{
		text[i].Clear();
	}
}


HmiTextWndPage* spt::HmiTextWnd::GetWndCell(uint32 Index)
{
	if (Index < M_ArrLen(text))
	{
		return &text[Index];
	}
	return 0;
}

void spt::HmiTextWnd::ShowSelf()
{
	if (mode == E_SinglePage)
	{

	}
	else if (mode == E_ScrollPage)
	{

	}
	else if (mode == E_ContinuePage)
	{

	}
}

void spt::HmiTextWnd::ShowSinglePage()
{
	HmiKey key;
	SetPeriodUpdate(1, 200);
	uint32 step;
	if (updateFunc)
	{
		key.Key1 = 0;
		updateFunc(*this, 0, totalPage, key);
	}
	while (1)
	{
		if (this->key->Pop(key))
		{
			if (key.Key1 == EK1_KEYVALUE)
			{
				E_KEY2 k2 = (E_KEY2)key.Key2;
				switch (k2)
				{
				case spt::EK_ENTER:
					SetUpdate(1);
					break;
				case spt::EK_LEFT:
					step = totalPage / 10;
					if (!step)
					{
						step = 1;
					}
					if (page > step)
					{
						page = page - step;
					}
					else
					{
						page = 0;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					SetUpdate(1);
					break;
				case spt::EK_UP:
					if (page >= step)
					{
						page = page - step;
					}
					else
					{
						page = totalPage - step;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					SetUpdate(1);
					break;
				case spt::EK_RIGHT:
					step = totalPage / 10;
					if (!step)
					{
						step = 1;
					}
					if (page >= totalPage)
					{
						page = totalPage - 1;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					SetUpdate(1);
					break;
				case spt::EK_DOWN:
					step = 1;
					page = totalPage + step;
					if (page >= totalPage)
					{
						page = 0;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					SetUpdate(1);
					break;
				case spt::EK_ESC:
					ReDrawRect();
					gd->Update(rect);
					return;
				case spt::EK_MD_STOP:
					ReDrawRect();
					gd->Update(rect);
					return;
				default:
					break;
				}
				HmiMain::Instance().MsSleep(20);
			}
			else if (updateFunc)
			{
				if (key.Key1 == EK1_ASSIC)
				{
					updateFunc(*this, page, totalPage, key);
					SetUpdate(1);
				}
				HmiMain::Instance().MsSleep(50);
			}
		}
		else
		{
			HmiMain::Instance().MsSleep(100);
		}
		WidTextWnd::Show();
	}
	ReDrawRect();
	gd->Update(rect);
	return;
}

void spt::HmiTextWnd::ShowScrollPage()
{
	HmiKey key;
	SetPeriodUpdate(1, 200);
	uint32 step;
	if (updateFunc)
	{
		key.Key1 = 0;
		updateFunc(*this, 0, totalPage, key);
	}
	while (1)
	{
		if (this->key->Pop(key))
		{
			if (key.Key1 == EK1_KEYVALUE)
			{
				E_KEY2 k2 = (E_KEY2)key.Key2;
				switch (k2)
				{
				case spt::EK_ENTER:
					SetUpdate(1);
					break;
				case spt::EK_LEFT:
					step = totalPage / 10;
					if (!step)
					{
						step = 1;
					}
					if (page > step)
					{
						page = page - step;
					}
					else
					{
						page = 0;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					break;
				case spt::EK_UP:
					if (page >= step)
					{
						page = page - step;
					}
					else
					{
						page = totalPage - step;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					break;
				case spt::EK_RIGHT:
					step = totalPage / 10;
					if (!step)
					{
						step = 1;
					}
					if (page >= totalPage)
					{
						page = totalPage - 1;
					}
					if (updateFunc)
					{
						updateFunc(*this, page, totalPage, key);
					}
					break;
				case spt::EK_DOWN:
					step = 1;
					page = page + step;
					if (page >= total)
					{
						page = 0;
					}
					title.SetPage(page, total);
					first = 1;
					if (updateFunc)
					{
						updateFunc(*this, page, total, key);
					}
					break;
				case spt::EK_ESC:
					UnShow();
					gd->Update(rect);
					return;
				case spt::EK_MD_STOP:
					UnShow();
					gd->Update(rect);
					return;
				default:

					break;
				}
			}
			else if (updateFunc)
			{
				total = title.TotalPage();
				page = title.Page();
				if (key.Key1 == EK1_ASSIC)
				{
					updateFunc(*this, page, total, key);
					first = 1;
				}
			}
		}
		else
		{
			HmiMain::Instance().MsSleep(50);
		}
		if (timer.Status(100))
		{
			if (first)
			{
				first = 0;
				AutoLayerOut();
				HmiWidSinglePage::Show(E_AllFrame);
				gd->Update(rect);
				timer.StartTimer();
			}
			else if (timer.Status(2000))
			{
				HmiWidSinglePage::Show(E_Update);
				gd->Update(rect);
				timer.StartTimer();
			}
		}
	}
	UnShow();
	gd->Update(rect);
	return;
}

void spt::HmiTextWnd::ShowContinuePage()
{
	HmiKey key;
	bool8 first = 1;
	MsStampTimer timer;
	timer.Enable(1);
	uint32 total;
	uint32 step;
	uint32 page;
	if (updateFunc)
	{
		key.Key1 = 0;
		updateFunc(*this, 0, title.TotalPage(), key);
	}
	totalLine = text[0].LineNum();
	curLine = 0;
	while (1)
	{
		if (this->key->Pop(key))
		{
			if (key.Key1 == EK1_KEYVALUE)
			{
				E_KEY2 k2 = (E_KEY2)key.Key2;
				switch (k2)
				{
				case spt::EK_ENTER:
					first = 1;
					break;
				case spt::EK_LEFT:
					total = title.TotalPage();
					step = 1;
					if (!step)
					{
						step = 1;
					}
					page = title.Page();
					if (page > step)
					{
						page = page - step;
					}
					else
					{
						page = 0;
					}
					curLine = 0;
					title.SetPage(page, total);
					first = 1;
					if (updateFunc)
					{
						updateFunc(*this, page, total, key);
					}
					AutoLayerOut();
					break;
				case spt::EK_UP:
					total = title.TotalPage();
					step = context.MaxDispRowNum() - 1;
					page = title.Page();
					if (curLine >= step)
					{
						curLine = curLine - step;
					}
					else
					{
						curLine = 0;
					}
					title.SetLine(curLine, totalLine);
					title.SetPage(page, total);
					first = 1;
					AutoLayerOut();
					break;
				case spt::EK_RIGHT:
					total = title.TotalPage();
					step = 1;
					if (!step)
					{
						step = 1;
					}
					page = title.Page() + step;
					if (page >= total)
					{
						page = total - 1;
					}
					curLine = 0;
					title.SetPage(page, total);
					first = 1;
					if (updateFunc)
					{
						updateFunc(*this, page, total, key);
					}
					AutoLayerOut();
					break;
				case spt::EK_DOWN:
					total = title.TotalPage();
					step = context.MaxDispRowNum() - 1;
					page = title.Page();
					uint32 c;
					c = curLine + step;
					if (c < totalLine)
					{
						curLine = c;
					}
					title.SetLine(curLine, totalLine);
					title.SetPage(page, total);
					first = 1;
					AutoLayerOut();
					break;
				case spt::EK_ESC:
					UnShow();
					gd->Update(rect);
					return;
				case spt::EK_MD_STOP:
					UnShow();
					gd->Update(rect);
					return;
				default:

					break;
				}
			}
			else if (updateFunc)
			{
				total = title.TotalPage();
				page = title.Page();
				if (key.Key1 == EK1_ASSIC)
				{
					updateFunc(*this, page, total, key);
					first = 1;
				}
			}
		}
		else
		{
			HmiMain::Instance().MsSleep(50);
		}
		if (timer.Status(100))
		{
			if (first)
			{
				AutoLayerOut();
				first = 0;
				HmiWidSinglePage::Show(E_AllFrame);
				gd->Update(rect);
				timer.StartTimer();
			}
			else if (timer.Status(2000))
			{
				HmiWidSinglePage::Show(E_Update);
				gd->Update(rect);
				timer.StartTimer();
			}
		}
	}
	UnShow();
	gd->Update(rect);
	return;
}

void spt::HmiTextWndCell::ShowSelf(ShowType Type)
{
	if (isVisible && isEnable)
	{

	}
	else
	{
		return;
	}
	uint32 row = 0;
	if (IsHmiWidContextParent())
	{
		HmiWidContextArea* p = (HmiWidContextArea*)parent;
		TransString ts;
		ts.SetBuf(text.Str());
		String100B str;
		uint16 y = Row;
		while (!ts.IsEnd())
		{
			str.Clear();
			if (ts.GetLine(str))
			{
				row++;
				if (row < firstDispLine)
				{
					continue;
				}
				p->SetText(y, Col, str.Str());
				y++;
				if (y >= p->MaxDispRowNum())
				{
					break;
				}
			}
		}
	}
}

uint16 spt::HmiTextWndCell::DispPageNum()
{
	return dispPageNum;
}

void spt::HmiTextWndCell::SetDispPageNum(uint16 page)
{
	dispPageNum = page;
}

uint16 spt::HmiTextWndCell::FirstDispLine()
{
	return firstDispLine;
}

uint16 spt::HmiTextWndCell::SetFirstDispLine(uint16 FirstDispLine)
{
	return firstDispLine = FirstDispLine;
}

uint16 spt::HmiTextWndPage::Page()
{
	return dispPageNum;
}

void spt::HmiTextWndPage::SetPage(uint32 Page, const char* Text)
{
	dispPageNum = Page;
	if (ctx != Text)
	{
		ctx = Text;
		isctxupdate = 1;
	}
}

void spt::HmiTextWndPage::Clear()
{
	isctxupdate = 1;
	dispPageNum = -1;
	ctx.Clear();
}

void spt::HmiTextWndPage::SetUpdate()
{
	isctxupdate = 1;
}
